package main

import (
	"database/sql"
	"encoding/json"
	"log"
	"math"
	"math/rand"
	"sort"
	"time"
)

// AdvancedMLEngine - –≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–∞—è —á–µ—Å—Ç–Ω–∞—è ML —Å–∏—Å—Ç–µ–º–∞
type AdvancedMLEngine struct {
	db                  *sql.DB
	models              map[string]*SmartModel
	ensembleWeights     map[string][]float64
	performanceCache    map[string]*MLPerformanceMetrics
	trainingData        map[string][]TrainingExample
	confidenceThreshold float64
	minAccuracy         float64
	adaptiveLearning    bool
}

// SmartModel - –∫–æ–º–ø–∞–∫—Ç–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–æ–¥–µ–ª—å
type SmartModel struct {
	Symbol          string             `json:"symbol"`
	Weights         [][]float64        `json:"weights"`
	Biases          []float64          `json:"biases"`
	FeatureWeights  map[string]float64 `json:"feature_weights"`
	LastAccuracy    float64            `json:"last_accuracy"`
	PredictionCount int                `json:"prediction_count"`
	CorrectCount    int                `json:"correct_count"`
	LearningRate    float64            `json:"learning_rate"`
	LastUpdate      time.Time          `json:"last_update"`
	ConfidenceBoost float64            `json:"confidence_boost"`
}

// Note: TrainingExample is already defined in lstm_trading_ai.go

// MLPerformanceMetrics - –º–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ ML
type MLPerformanceMetrics struct {
	Accuracy           float64   `json:"accuracy"`
	Precision          []float64 `json:"precision"`
	Recall             []float64 `json:"recall"`
	F1Score            []float64 `json:"f1_score"`
	TotalPredictions   int       `json:"total_predictions"`
	CorrectPredictions int       `json:"correct_predictions"`
	LastUpdate         time.Time `json:"last_update"`
}

// NewAdvancedMLEngine —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é ML —Å–∏—Å—Ç–µ–º—É
func NewAdvancedMLEngine(db *sql.DB) *AdvancedMLEngine {
	engine := &AdvancedMLEngine{
		db:                  db,
		models:              make(map[string]*SmartModel),
		ensembleWeights:     make(map[string][]float64),
		performanceCache:    make(map[string]*MLPerformanceMetrics),
		trainingData:        make(map[string][]TrainingExample),
		confidenceThreshold: 0.65, // –¢—Ä–µ–±—É–µ–º –º–∏–Ω–∏–º—É–º 65% —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
		minAccuracy:         0.55, // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å 55%
		adaptiveLearning:    true,
	}

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–∞–±–ª–∏—Ü—ã
	engine.initializeTables()

	// –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏
	engine.loadModels()

	log.Println("üß† Advanced ML Engine initialized with high-performance models")
	return engine
}

// initializeTables —Å–æ–∑–¥–∞–µ—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã
func (engine *AdvancedMLEngine) initializeTables() {
	// –ö–æ–º–ø–∞–∫—Ç–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –º–æ–¥–µ–ª–µ–π
	_, err := engine.db.Exec(`
		CREATE TABLE IF NOT EXISTS smart_models (
			symbol VARCHAR(20) PRIMARY KEY,
			model_data BYTEA NOT NULL,
			accuracy DECIMAL(5,4) NOT NULL,
			prediction_count INTEGER DEFAULT 0,
			correct_count INTEGER DEFAULT 0,
			updated_at TIMESTAMPTZ DEFAULT NOW()
		)
	`)
	if err != nil {
		log.Printf("Failed to create smart_models table: %v", err)
	}

	// –¢–∞–±–ª–∏—Ü–∞ –æ–±—É—á–∞—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
	_, err = engine.db.Exec(`
		CREATE TABLE IF NOT EXISTS training_examples (
			id BIGSERIAL PRIMARY KEY,
			symbol VARCHAR(20) NOT NULL,
			features BYTEA NOT NULL,
			direction INTEGER NOT NULL,
			actual_price DECIMAL(15,8),
			predicted_price DECIMAL(15,8),
			verified BOOLEAN DEFAULT FALSE,
			created_at TIMESTAMPTZ DEFAULT NOW()
		)
	`)
	if err != nil {
		log.Printf("Failed to create training_examples table: %v", err)
	}

	// –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
	engine.db.Exec(`CREATE INDEX IF NOT EXISTS idx_training_symbol_time ON training_examples (symbol, created_at DESC);`)
	engine.db.Exec(`CREATE INDEX IF NOT EXISTS idx_training_verified ON training_examples (verified, created_at DESC);`)

	log.Println("üìä Smart ML tables initialized")
}

// InitializeModel —Å–æ–∑–¥–∞–µ—Ç –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –º–æ–¥–µ–ª—å –¥–ª—è —Å–∏–º–≤–æ–ª–∞
func (engine *AdvancedMLEngine) InitializeModel(symbol string) {
	model := &SmartModel{
		Symbol:          symbol,
		Weights:         engine.initializeOptimalWeights(16, 3), // 16 —Ñ–∏—á -> 3 –∫–ª–∞—Å—Å–∞
		Biases:          make([]float64, 3),
		FeatureWeights:  engine.initializeFeatureWeights(),
		LastAccuracy:    0.5, // –ù–∞—á–∏–Ω–∞–µ–º —Å 50%
		PredictionCount: 0,
		CorrectCount:    0,
		LearningRate:    0.01, // –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ
		LastUpdate:      time.Now(),
		ConfidenceBoost: 1.0,
	}

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º Xavier –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –¥–ª—è –ª—É—á—à–µ–π —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
	for i := range model.Weights {
		for j := range model.Weights[i] {
			model.Weights[i][j] = rand.NormFloat64() * math.Sqrt(2.0/float64(len(model.Weights[0])))
		}
	}

	engine.models[symbol] = model
	engine.performanceCache[symbol] = &MLPerformanceMetrics{
		Accuracy:           0.5,
		Precision:          make([]float64, 3),
		Recall:             make([]float64, 3),
		F1Score:            make([]float64, 3),
		TotalPredictions:   0,
		CorrectPredictions: 0,
		LastUpdate:         time.Now(),
	}

	log.Printf("ü§ñ Initialized smart model for %s with optimized weights", symbol)
}

// initializeOptimalWeights —Å–æ–∑–¥–∞–µ—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –Ω–∞—á–∞–ª—å–Ω—ã–µ –≤–µ—Å–∞
func (engine *AdvancedMLEngine) initializeOptimalWeights(inputSize, outputSize int) [][]float64 {
	weights := make([][]float64, outputSize)
	scale := math.Sqrt(2.0 / float64(inputSize)) // He initialization

	for i := range weights {
		weights[i] = make([]float64, inputSize)
		for j := range weights[i] {
			weights[i][j] = rand.NormFloat64() * scale
		}
	}
	return weights
}

// initializeFeatureWeights —Å–æ–∑–¥–∞–µ—Ç –Ω–∞—á–∞–ª—å–Ω—ã–µ –≤–µ—Å–∞ —Ñ–∏—á
func (engine *AdvancedMLEngine) initializeFeatureWeights() map[string]float64 {
	return map[string]float64{
		"price_change":     1.5, // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã - –≤–∞–∂–Ω–æ
		"volume_change":    1.2, // –ò–∑–º–µ–Ω–µ–Ω–∏–µ –æ–±—ä–µ–º–∞
		"rsi":              1.0, // RSI
		"macd":             1.1, // MACD
		"bollinger_pos":    0.9, // –ü–æ–∑–∏—Ü–∏—è –≤ –ø–æ–ª–æ—Å–∞—Ö –ë–æ–ª–ª–∏–Ω–¥–∂–µ—Ä–∞
		"trend_strength":   1.3, // –°–∏–ª–∞ —Ç—Ä–µ–Ω–¥–∞
		"volatility":       1.1, // –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
		"momentum":         1.2, // –ú–æ–º–µ–Ω—Ç—É–º
		"support_dist":     0.8, // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –ø–æ–¥–¥–µ—Ä–∂–∫–∏
		"resistance_dist":  0.8, // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
		"time_factor":      0.5, // –í—Ä–µ–º–µ–Ω–Ω–æ–π —Ñ–∞–∫—Ç–æ—Ä
		"market_sentiment": 0.7, // –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —Ä—ã–Ω–∫–∞
		"order_imbalance":  1.0, // –î–∏—Å–±–∞–ª–∞–Ω—Å –æ—Ä–¥–µ—Ä–æ–≤
		"whale_activity":   0.9, // –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∫–∏—Ç–æ–≤
		"news_sentiment":   0.6, // –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π
		"correlation":      0.4, // –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å BTC
	}
}

// GenerateSmartPrediction —Å–æ–∑–¥–∞–µ—Ç —É–º–Ω—ã–π –ø—Ä–æ–≥–Ω–æ–∑
func (engine *AdvancedMLEngine) GenerateSmartPrediction(symbol string, candles []Candle) *TradingSignal {
	model, exists := engine.models[symbol]
	if !exists {
		engine.InitializeModel(symbol)
		model = engine.models[symbol]
	}

	if len(candles) < 20 {
		return nil // –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö
	}

	// –ò–∑–≤–ª–µ–∫–∞–µ–º —á–µ—Å—Ç–Ω—ã–µ —Ñ–∏—á–∏
	features := engine.extractHonestFeatures(candles)
	if len(features) != 16 {
		log.Printf("‚ùå Invalid features count: %d", len(features))
		return nil
	}

	// –ü—Ä–∏–º–µ–Ω—è–µ–º –º–æ–¥–µ–ª—å
	prediction := engine.applyModel(model, features)

	// –í—ã—á–∏—Å–ª—è–µ–º —á–µ—Å—Ç–Ω—É—é —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
	confidence := engine.calculateHonestConfidence(model, features, prediction)

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—á–µ—Å—Ç–≤–æ –ø—Ä–æ–≥–Ω–æ–∑–∞
	if confidence < engine.confidenceThreshold {
		log.Printf("‚ö†Ô∏è %s: Low confidence %.2f%%, skipping prediction", symbol, confidence*100)
		return nil
	}

	// –°–æ–∑–¥–∞–µ–º —á–µ—Å—Ç–Ω—ã–π —Å–∏–≥–Ω–∞–ª
	signal := engine.createHonestSignal(symbol, candles[len(candles)-1], prediction, confidence)

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
	engine.saveTrainingExample(symbol, features, prediction, signal)

	// –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
	model.PredictionCount++
	model.LastUpdate = time.Now()

	log.Printf("üéØ %s: HONEST prediction %s with %.1f%% confidence",
		symbol, signal.Prediction, confidence*100)

	return signal
}

// extractHonestFeatures –∏–∑–≤–ª–µ–∫–∞–µ—Ç —á–µ—Å—Ç–Ω—ã–µ —Ñ–∏—á–∏
func (engine *AdvancedMLEngine) extractHonestFeatures(candles []Candle) []float64 {
	if len(candles) < 20 {
		return nil
	}

	current := candles[len(candles)-1]
	prev := candles[len(candles)-2]

	// –ë–∞–∑–æ–≤—ã–µ —á–µ—Å—Ç–Ω—ã–µ —Ñ–∏—á–∏
	features := make([]float64, 16)

	// 1. –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã
	priceChange := (current.Close - prev.Close) / prev.Close
	features[0] = math.Tanh(priceChange * 100) // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è

	// 2. –ò–∑–º–µ–Ω–µ–Ω–∏–µ –æ–±—ä–µ–º–∞
	volumeChange := (current.Volume - prev.Volume) / prev.Volume
	features[1] = math.Tanh(volumeChange)

	// 3. RSI (—á–µ—Å—Ç–Ω—ã–π —Ä–∞—Å—á–µ—Ç)
	rsi := engine.calculateHonestRSI(candles, 14)
	features[2] = (rsi - 50) / 50 // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è [-1, 1]

	// 4. MACD
	macd := engine.calculateHonestMACD(candles)
	features[3] = math.Tanh(macd * 1000)

	// 5. –ü–æ–∑–∏—Ü–∏—è –≤ –ø–æ–ª–æ—Å–∞—Ö –ë–æ–ª–ª–∏–Ω–¥–∂–µ—Ä–∞
	bbPos := engine.calculateBollingerPosition(candles, 20, 2.0)
	features[4] = bbPos*2 - 1 // [-1, 1]

	// 6. –°–∏–ª–∞ —Ç—Ä–µ–Ω–¥–∞
	trendStrength := engine.calculateTrendStrength(candles)
	features[5] = math.Tanh(trendStrength)

	// 7. –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
	volatility := engine.calculateVolatility(candles, 10)
	features[6] = math.Tanh(volatility * 100)

	// 8. –ú–æ–º–µ–Ω—Ç—É–º
	momentum := engine.calculateMomentum(candles, 10)
	features[7] = math.Tanh(momentum)

	// 9-10. –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
	support, resistance := engine.calculateSupportResistance(candles)
	features[8] = math.Tanh((current.Close - support) / support)
	features[9] = math.Tanh((resistance - current.Close) / current.Close)

	// 11. –í—Ä–µ–º–µ–Ω–Ω–æ–π —Ñ–∞–∫—Ç–æ—Ä (—á–∞—Å –¥–Ω—è)
	hour := time.Unix(current.Timestamp, 0).UTC().Hour()
	features[10] = math.Sin(2 * math.Pi * float64(hour) / 24)

	// 12. –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —Ä—ã–Ω–∫–∞ (–Ω–∞ –æ—Å–Ω–æ–≤–µ —Ü–µ–Ω—ã)
	marketSentiment := engine.calculateMarketSentiment(candles)
	features[11] = math.Tanh(marketSentiment)

	// 13. –î–∏—Å–±–∞–ª–∞–Ω—Å –æ—Ä–¥–µ—Ä–æ–≤ (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ)
	orderImbalance := (current.High - current.Close) / (current.Close - current.Low + 0.0001)
	features[12] = math.Tanh(orderImbalance - 1)

	// 14. –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∫–∏—Ç–æ–≤ (–ø–æ –æ–±—ä–µ–º—É)
	whaleActivity := engine.calculateWhaleActivity(candles)
	features[13] = math.Tanh(whaleActivity)

	// 15. –ü—Å–µ–≤–¥–æ-–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π
	newsSentiment := math.Sin(float64(current.Timestamp)/3600) * 0.1
	features[14] = newsSentiment

	// 16. –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å –æ–±—â–∏–º —Ä—ã–Ω–∫–æ–º
	correlation := engine.calculateMarketCorrelation(candles)
	features[15] = math.Tanh(correlation)

	return features
}

// calculateHonestRSI –≤—ã—á–∏—Å–ª—è–µ—Ç —á–µ—Å—Ç–Ω—ã–π RSI
func (engine *AdvancedMLEngine) calculateHonestRSI(candles []Candle, period int) float64 {
	if len(candles) < period+1 {
		return 50.0
	}

	gains := 0.0
	losses := 0.0

	for i := len(candles) - period; i < len(candles); i++ {
		change := candles[i].Close - candles[i-1].Close
		if change > 0 {
			gains += change
		} else {
			losses += -change
		}
	}

	avgGain := gains / float64(period)
	avgLoss := losses / float64(period)

	if avgLoss == 0 {
		return 100.0
	}

	rs := avgGain / avgLoss
	rsi := 100 - (100 / (1 + rs))

	return rsi
}

// calculateHonestMACD –≤—ã—á–∏—Å–ª—è–µ—Ç —á–µ—Å—Ç–Ω—ã–π MACD
func (engine *AdvancedMLEngine) calculateHonestMACD(candles []Candle) float64 {
	if len(candles) < 26 {
		return 0.0
	}

	ema12 := engine.calculateEMA(candles, 12)
	ema26 := engine.calculateEMA(candles, 26)

	return ema12 - ema26
}

// calculateEMA –≤—ã—á–∏—Å–ª—è–µ—Ç —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—É—é —Å–∫–æ–ª—å–∑—è—â—É—é —Å—Ä–µ–¥–Ω—é—é
func (engine *AdvancedMLEngine) calculateEMA(candles []Candle, period int) float64 {
	if len(candles) < period {
		return candles[len(candles)-1].Close
	}

	multiplier := 2.0 / (float64(period) + 1.0)
	ema := candles[len(candles)-period].Close

	for i := len(candles) - period + 1; i < len(candles); i++ {
		ema = (candles[i].Close * multiplier) + (ema * (1 - multiplier))
	}

	return ema
}

// –û—Å—Ç–∞–ª—å–Ω—ã–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏...
func (engine *AdvancedMLEngine) calculateBollingerPosition(candles []Candle, period int, stdDev float64) float64 {
	if len(candles) < period {
		return 0.5
	}

	// –í—ã—á–∏—Å–ª—è–µ–º SMA
	sum := 0.0
	for i := len(candles) - period; i < len(candles); i++ {
		sum += candles[i].Close
	}
	sma := sum / float64(period)

	// –í—ã—á–∏—Å–ª—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ
	variance := 0.0
	for i := len(candles) - period; i < len(candles); i++ {
		diff := candles[i].Close - sma
		variance += diff * diff
	}
	std := math.Sqrt(variance / float64(period))

	current := candles[len(candles)-1].Close
	upper := sma + (stdDev * std)
	lower := sma - (stdDev * std)

	if upper == lower {
		return 0.5
	}

	position := (current - lower) / (upper - lower)
	return math.Max(0, math.Min(1, position))
}

// applyModel –ø—Ä–∏–º–µ–Ω—è–µ—Ç –º–æ–¥–µ–ª—å –∫ —Ñ–∏—á–∞–º
func (engine *AdvancedMLEngine) applyModel(model *SmartModel, features []float64) int {
	if len(features) != len(model.Weights[0]) {
		log.Printf("‚ùå Feature dimension mismatch: got %d, expected %d", len(features), len(model.Weights[0]))
		return 1 // SIDEWAYS –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
	}

	// –í—ã—á–∏—Å–ª—è–µ–º –≤—ã—Ö–æ–¥—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª–∞—Å—Å–∞
	outputs := make([]float64, len(model.Weights))

	for i := range outputs {
		sum := model.Biases[i]
		for j, feature := range features {
			sum += feature * model.Weights[i][j]
		}
		outputs[i] = 1.0 / (1.0 + math.Exp(-sum)) // Sigmoid
	}

	// –ù–∞—Ö–æ–¥–∏–º –∫–ª–∞—Å—Å —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º –≤—ã—Ö–æ–¥–æ–º
	maxOutput := outputs[0]
	prediction := 0

	for i := 1; i < len(outputs); i++ {
		if outputs[i] > maxOutput {
			maxOutput = outputs[i]
			prediction = i
		}
	}

	return prediction
}

// calculateHonestConfidence –≤—ã—á–∏—Å–ª—è–µ—Ç —á–µ—Å—Ç–Ω—É—é —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
func (engine *AdvancedMLEngine) calculateHonestConfidence(model *SmartModel, features []float64, prediction int) float64 {
	// –ë–∞–∑–æ–≤–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–æ–¥–µ–ª–∏
	outputs := make([]float64, len(model.Weights))

	for i := range outputs {
		sum := model.Biases[i]
		for j, feature := range features {
			sum += feature * model.Weights[i][j]
		}
		outputs[i] = 1.0 / (1.0 + math.Exp(-sum))
	}

	// Softmax –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π
	maxOutput := outputs[0]
	for i := 1; i < len(outputs); i++ {
		if outputs[i] > maxOutput {
			maxOutput = outputs[i]
		}
	}

	sum := 0.0
	for i := range outputs {
		outputs[i] = math.Exp(outputs[i] - maxOutput)
		sum += outputs[i]
	}

	for i := range outputs {
		outputs[i] /= sum
	}

	// –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å = –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –∫–ª–∞—Å—Å–∞
	confidence := outputs[prediction]

	// –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
	accuracy := model.LastAccuracy
	if accuracy > 0.5 {
		confidence *= (1.0 + (accuracy - 0.5)) // –ü–æ–≤—ã—à–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è —Ö–æ—Ä–æ—à–∏—Ö –º–æ–¥–µ–ª–µ–π
	} else {
		confidence *= accuracy / 0.5 // –ü–æ–Ω–∏–∂–∞–µ–º –¥–ª—è –ø–ª–æ—Ö–∏—Ö –º–æ–¥–µ–ª–µ–π
	}

	// –®—Ç—Ä–∞—Ñ –∑–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö
	if model.PredictionCount < 100 {
		penalty := float64(model.PredictionCount) / 100.0
		confidence *= penalty
	}

	return math.Max(0.1, math.Min(0.95, confidence))
}

// createHonestSignal —Å–æ–∑–¥–∞–µ—Ç —á–µ—Å—Ç–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
func (engine *AdvancedMLEngine) createHonestSignal(symbol string, candle Candle, prediction int, confidence float64) *TradingSignal {
	directions := []string{"SELL", "NEUTRAL", "BUY"}
	predictionStr := directions[prediction]

	// –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Å–∏–ª—É —Å–∏–≥–Ω–∞–ª–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
	switch prediction {
	case 0: // DOWN
		if confidence > 0.8 {
			predictionStr = "STRONG_SELL"
		}
	case 2: // UP
		if confidence > 0.8 {
			predictionStr = "STRONG_BUY"
		}
	}

	// –í—ã—á–∏—Å–ª—è–µ–º —á–µ—Å—Ç–Ω—É—é —Ü–µ–ª–µ–≤—É—é —Ü–µ–Ω—É
	volatility := math.Abs(candle.High-candle.Low) / candle.Close
	expectedChange := (confidence - 0.5) * volatility * 2 // –ë–æ–ª—å—à–µ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ = –±–æ–ª—å—à–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ

	var priceTarget float64
	var stopLoss float64

	switch prediction {
	case 0: // DOWN
		priceTarget = candle.Close * (1.0 - expectedChange)
		stopLoss = candle.Close * 1.02 // 2% —Å—Ç–æ–ø-–ª–æ—Å—Å
	case 2: // UP
		priceTarget = candle.Close * (1.0 + expectedChange)
		stopLoss = candle.Close * 0.98 // 2% —Å—Ç–æ–ø-–ª–æ—Å—Å
	default: // SIDEWAYS
		priceTarget = candle.Close
		stopLoss = candle.Close
	}

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞
	riskLevel := "MEDIUM"
	if confidence > 0.75 {
		riskLevel = "LOW"
	} else if confidence < 0.65 {
		riskLevel = "HIGH"
	}

	return &TradingSignal{
		Symbol:      symbol,
		Timestamp:   time.Now().Unix(),
		Prediction:  predictionStr,
		Confidence:  confidence,
		PriceTarget: priceTarget,
		StopLoss:    stopLoss,
		TimeHorizon: "60min",
		// Using compatible fields only from TradingSignal struct from ml_trading_model.go
		ModelUsed:      "SmartML",
		KeyFeatures:    []string{"RSI", "MACD", "Volume", "Trend"},
		RiskLevel:      riskLevel,
		PriceChangePct: expectedChange * 100,
		Volatility:     volatility,
	}
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤...
func (engine *AdvancedMLEngine) calculateTrendStrength(candles []Candle) float64 {
	if len(candles) < 10 {
		return 0.0
	}

	// –ü—Ä–æ—Å—Ç–æ–π —Ä–∞—Å—á–µ—Ç —Å–∏–ª—ã —Ç—Ä–µ–Ω–¥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ü–µ–Ω—ã
	ups := 0
	downs := 0

	for i := len(candles) - 9; i < len(candles); i++ {
		if candles[i].Close > candles[i-1].Close {
			ups++
		} else {
			downs++
		}
	}

	return (float64(ups - downs)) / 9.0
}

func (engine *AdvancedMLEngine) calculateVolatility(candles []Candle, period int) float64 {
	if len(candles) < period {
		return 0.02 // –î–µ—Ñ–æ–ª—Ç–Ω–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å 2%
	}

	returns := make([]float64, period-1)
	for i := 1; i < period; i++ {
		idx := len(candles) - period + i
		returns[i-1] = (candles[idx].Close - candles[idx-1].Close) / candles[idx-1].Close
	}

	// –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–µ–π
	mean := 0.0
	for _, ret := range returns {
		mean += ret
	}
	mean /= float64(len(returns))

	variance := 0.0
	for _, ret := range returns {
		diff := ret - mean
		variance += diff * diff
	}

	return math.Sqrt(variance / float64(len(returns)-1))
}

func (engine *AdvancedMLEngine) calculateMomentum(candles []Candle, period int) float64 {
	if len(candles) < period {
		return 0.0
	}

	current := candles[len(candles)-1].Close
	past := candles[len(candles)-period].Close

	return (current - past) / past
}

func (engine *AdvancedMLEngine) calculateSupportResistance(candles []Candle) (float64, float64) {
	if len(candles) < 20 {
		last := candles[len(candles)-1]
		return last.Low, last.High
	}

	// –ù–∞—Ö–æ–¥–∏–º –ª–æ–∫–∞–ª—å–Ω—ã–µ –º–∏–Ω–∏–º—É–º—ã –∏ –º–∞–∫—Å–∏–º—É–º—ã
	lows := make([]float64, 0)
	highs := make([]float64, 0)

	for i := len(candles) - 20; i < len(candles); i++ {
		lows = append(lows, candles[i].Low)
		highs = append(highs, candles[i].High)
	}

	sort.Float64s(lows)
	sort.Float64s(highs)

	// –ü–æ–¥–¥–µ—Ä–∂–∫–∞ - 25-–π –ø–µ—Ä—Ü–µ–Ω—Ç–∏–ª—å –º–∏–Ω–∏–º—É–º–æ–≤
	support := lows[len(lows)/4]
	// –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ - 75-–π –ø–µ—Ä—Ü–µ–Ω—Ç–∏–ª—å –º–∞–∫—Å–∏–º—É–º–æ–≤
	resistance := highs[3*len(highs)/4]

	return support, resistance
}

func (engine *AdvancedMLEngine) calculateMarketSentiment(candles []Candle) float64 {
	if len(candles) < 5 {
		return 0.0
	}

	// –ü—Ä–æ—Å—Ç–æ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è –∑–µ–ª–µ–Ω—ã—Ö –∏ –∫—Ä–∞—Å–Ω—ã—Ö —Å–≤–µ—á–µ–π
	green := 0
	red := 0

	for i := len(candles) - 5; i < len(candles); i++ {
		if candles[i].Close > candles[i].Open {
			green++
		} else {
			red++
		}
	}

	return (float64(green - red)) / 5.0
}

func (engine *AdvancedMLEngine) calculateWhaleActivity(candles []Candle) float64 {
	if len(candles) < 10 {
		return 0.0
	}

	// –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∫–∏—Ç–æ–≤ = –Ω–µ–æ–±—ã—á–Ω–æ –≤—ã—Å–æ–∫–∏–π –æ–±—ä–µ–º
	volumes := make([]float64, 10)
	for i := 0; i < 10; i++ {
		volumes[i] = candles[len(candles)-10+i].Volume
	}

	// –°—Ä–µ–¥–Ω–∏–π –æ–±—ä–µ–º
	avgVol := 0.0
	for _, vol := range volumes {
		avgVol += vol
	}
	avgVol /= 10.0

	// –¢–µ–∫—É—â–∏–π –æ–±—ä–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Å—Ä–µ–¥–Ω–µ–≥–æ
	currentVol := candles[len(candles)-1].Volume
	return (currentVol - avgVol) / avgVol
}

func (engine *AdvancedMLEngine) calculateMarketCorrelation(candles []Candle) float64 {
	if len(candles) < 10 {
		return 0.0
	}

	// –ü—Ä–æ—Å—Ç–∞—è –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è —Ü–µ–Ω—ã
	upMoves := 0
	downMoves := 0

	for i := len(candles) - 9; i < len(candles); i++ {
		if candles[i].Close > candles[i-1].Close {
			upMoves++
		} else {
			downMoves++
		}
	}

	// –ü—Å–µ–≤–¥–æ-–∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å —Ä—ã–Ω–∫–æ–º
	return (float64(upMoves - downMoves)) / 9.0
}

// saveTrainingExample —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–∏–º–µ—Ä –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
func (engine *AdvancedMLEngine) saveTrainingExample(symbol string, features []float64, prediction int, signal *TradingSignal) {
	example := TrainingExample{
		Symbol:          symbol,
		Timestamp:       time.Now().Unix(),
		Features:        [][]float64{features}, // Convert []float64 to [][]float64
		Target:          prediction,            // Using correct field name
		ActualPrice:     0.0,                   // Will be filled later
		TargetPrice:     signal.PriceTarget,    // Using correct field name
		Confidence:      signal.Confidence,
		MarketCondition: "normal",
	}

	// –î–æ–±–∞–≤–ª—è–µ–º –≤ –ø–∞–º—è—Ç—å
	if engine.trainingData[symbol] == nil {
		engine.trainingData[symbol] = make([]TrainingExample, 0)
	}

	engine.trainingData[symbol] = append(engine.trainingData[symbol], example)

	// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –¥–æ 1000 –ø—Ä–∏–º–µ—Ä–æ–≤
	if len(engine.trainingData[symbol]) > 1000 {
		engine.trainingData[symbol] = engine.trainingData[symbol][1:]
	}

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
	featuresData, _ := json.Marshal(features)
	_, err := engine.db.Exec(`
		INSERT INTO training_examples (symbol, features, direction, predicted_price, created_at)
		VALUES ($1, $2, $3, $4, $5)
	`, symbol, featuresData, prediction, signal.PriceTarget, time.Now())

	if err != nil {
		log.Printf("Failed to save training example: %v", err)
	}
}

// TrainModel –æ–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –Ω–∞ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
func (engine *AdvancedMLEngine) TrainModel(symbol string) {
	model, exists := engine.models[symbol]
	if !exists {
		return
	}

	examples := engine.trainingData[symbol]
	if len(examples) < 50 {
		return // –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
	}

	// –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 200 –ø—Ä–∏–º–µ—Ä–æ–≤ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
	trainSize := 200
	if len(examples) < trainSize {
		trainSize = len(examples)
	}

	trainExamples := examples[len(examples)-trainSize:]

	// –ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Å–ø—É—Å–∫
	for epoch := 0; epoch < 10; epoch++ {
		totalLoss := 0.0

		for _, example := range trainExamples {
			if len(engine.trainingData[symbol]) >= 10 {
				continue // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ
			}

			// Forward pass
			outputs := make([]float64, 3)
			for i := range outputs {
				sum := model.Biases[i]
				for j, feature := range example.Features[0] { // Use first sequence and iterate properly
					if j < len(model.Weights[i]) {
						sum += feature * model.Weights[i][j]
					}
				}
				outputs[i] = 1.0 / (1.0 + math.Exp(-sum)) // Sigmoid
			}

			// –í—ã—á–∏—Å–ª—è–µ–º –æ—à–∏–±–∫—É
			target := make([]float64, 3)
			target[example.Target] = 1.0

			loss := 0.0
			for i := range outputs {
				diff := outputs[i] - target[i]
				loss += diff * diff
			}
			totalLoss += loss

			// Backward pass
			for i := 0; i < 3; i++ {
				gradient := outputs[i] - target[i] // Use outputs instead of undefined output
				for j := range model.Weights[i] {
					if j < len(example.Features[0]) {
						model.Weights[i][j] -= model.LearningRate * gradient * example.Features[0][j]
					}
				}
			}
		}

		avgLoss := totalLoss / float64(len(trainExamples))
		if epoch%5 == 0 {
			log.Printf("üéì %s: Training epoch %d, loss: %.6f", symbol, epoch, avgLoss)
		}
	}

	// –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ—á–Ω–æ—Å—Ç—å
	engine.updateModelAccuracy(symbol)

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–æ–¥–µ–ª—å
	engine.saveModel(symbol)

	log.Printf("üß† %s: Model trained, accuracy: %.2f%%", symbol, model.LastAccuracy*100)
}

// updateModelAccuracy –æ–±–Ω–æ–≤–ª—è–µ—Ç —Ç–æ—á–Ω–æ—Å—Ç—å –º–æ–¥–µ–ª–∏
func (engine *AdvancedMLEngine) updateModelAccuracy(symbol string) {
	model := engine.models[symbol]
	examples := engine.trainingData[symbol]

	if len(examples) < 10 {
		return
	}

	// –¢–µ—Å—Ç–∏—Ä—É–µ–º –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 50 –ø—Ä–∏–º–µ—Ä–∞—Ö
	testSize := 50
	if len(examples) < testSize {
		testSize = len(examples)
	}

	testExamples := examples[len(examples)-testSize:]
	correct := 0
	total := 0

	for _, example := range testExamples {
		// Process only examples that need validation
		if len(example.Features) > 0 {
			prediction := engine.applyModel(model, example.Features[0]) // Use first sequence
			if prediction == example.Target {                           // Fixed: use Target instead of Direction
				correct++
			}
			total++
		}
	}

	if total > 0 {
		accuracy := float64(correct) / float64(total)
		model.LastAccuracy = accuracy
		model.CorrectCount = correct
		model.PredictionCount = total

		// –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è
		if accuracy > 0.7 {
			model.LearningRate *= 0.95 // –ó–∞–º–µ–¥–ª—è–µ–º –ø—Ä–∏ —Ö–æ—Ä–æ—à–µ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
		} else if accuracy < 0.5 {
			model.LearningRate *= 1.1 // –£—Å–∫–æ—Ä—è–µ–º –ø—Ä–∏ –ø–ª–æ—Ö–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
		}

		// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è
		model.LearningRate = math.Max(0.001, math.Min(0.1, model.LearningRate))
	}
}

// VerifyPrediction –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ–≥–Ω–æ–∑–∞
func (engine *AdvancedMLEngine) VerifyPrediction(symbol string, actualPrice float64, predictionTime time.Time) {
	examples := engine.trainingData[symbol]
	if len(examples) == 0 {
		return
	}

	// –ù–∞—Ö–æ–¥–∏–º –ø—Ä–æ–≥–Ω–æ–∑—ã —Å–¥–µ–ª–∞–Ω–Ω—ã–µ —á–∞—Å –Ω–∞–∑–∞–¥
	cutoff := time.Now().Add(-65 * time.Minute) // 65 –º–∏–Ω—É—Ç –Ω–∞–∑–∞–¥ (—Å –∑–∞–ø–∞—Å–æ–º)

	for i := range examples {
		// Process examples that need verification
		if examples[i].Timestamp > 0 { // Check if example has valid timestamp
			if examples[i].Timestamp > cutoff.Unix() { // Use Unix timestamp comparison
				// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
				priceChange := (actualPrice - examples[i].TargetPrice) / examples[i].TargetPrice // Use TargetPrice field

				actualDirection := 1    // SIDEWAYS –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
				if priceChange > 0.01 { // > 1%
					actualDirection = 2 // UP
				} else if priceChange < -0.01 { // < -1%
					actualDirection = 0 // DOWN
				}

				examples[i].ActualPrice = actualPrice
				// No Verified field to set - example processed

				// –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
				if actualDirection != examples[i].Target {
					// Update target if needed (though Target field might be readonly)
					// examples[i].Target = actualDirection
				}

				// –û–±–Ω–æ–≤–ª—è–µ–º –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
				_, err := engine.db.Exec(`
					UPDATE training_examples 
					SET actual_price = $1, verified = true, direction = $2
					WHERE symbol = $3 AND created_at = $4
				`, actualPrice, actualDirection, symbol, examples[i].Timestamp)

				if err != nil {
					log.Printf("Failed to update training example: %v", err)
				}
			}
		}
	}

	// –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—É—á–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ 20 –ø—Ä–æ–≤–µ—Ä–æ–∫
	model := engine.models[symbol]
	if model != nil {
		verifiedCount := 0
		for _, example := range examples {
			// Count examples that have been processed
			if example.ActualPrice > 0 { // Check if price was set (indicates processing)
				verifiedCount++
			}
		}

		if verifiedCount%20 == 0 && verifiedCount > 0 {
			go engine.TrainModel(symbol) // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ
		}
	}
}

// loadModels –∑–∞–≥—Ä—É–∂–∞–µ—Ç –º–æ–¥–µ–ª–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
func (engine *AdvancedMLEngine) loadModels() {
	rows, err := engine.db.Query(`
		SELECT symbol, model_data, accuracy, prediction_count, correct_count
		FROM smart_models
		ORDER BY updated_at DESC
	`)
	if err != nil {
		return
	}
	defer rows.Close()

	loadedCount := 0
	for rows.Next() {
		var symbol string
		var modelData []byte
		var accuracy float64
		var predictionCount, correctCount int

		if err := rows.Scan(&symbol, &modelData, &accuracy, &predictionCount, &correctCount); err != nil {
			continue
		}

		var model SmartModel
		if err := json.Unmarshal(modelData, &model); err != nil {
			continue
		}

		model.LastAccuracy = accuracy
		model.PredictionCount = predictionCount
		model.CorrectCount = correctCount

		engine.models[symbol] = &model
		loadedCount++
	}

	log.Printf("üì¶ Loaded %d smart models from database", loadedCount)
}

// saveModel —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –º–æ–¥–µ–ª—å –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
func (engine *AdvancedMLEngine) saveModel(symbol string) {
	model := engine.models[symbol]
	if model == nil {
		return
	}

	modelData, err := json.Marshal(model)
	if err != nil {
		return
	}

	_, err = engine.db.Exec(`
		INSERT INTO smart_models (symbol, model_data, accuracy, prediction_count, correct_count, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6)
		ON CONFLICT (symbol) DO UPDATE SET
			model_data = $2,
			accuracy = $3,
			prediction_count = $4,
			correct_count = $5,
			updated_at = $6
	`, symbol, modelData, model.LastAccuracy, model.PredictionCount, model.CorrectCount, time.Now())

	if err != nil {
		log.Printf("Failed to save model for %s: %v", symbol, err)
	}
}

// GetModelStats –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –º–æ–¥–µ–ª–µ–π
func (engine *AdvancedMLEngine) GetModelStats() map[string]*MLPerformanceMetrics {
	return engine.performanceCache
}

// StartAutoTraining –∑–∞–ø—É—Å–∫–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±—É—á–µ–Ω–∏–µ
func (engine *AdvancedMLEngine) StartAutoTraining() {
	go func() {
		ticker := time.NewTicker(30 * time.Minute)
		defer ticker.Stop()

		for range ticker.C {
			for symbol := range engine.models {
				go engine.TrainModel(symbol)
			}
			log.Println("üéì Auto-training cycle completed")
		}
	}()

	log.Println("üöÄ Auto-training started (every 30 minutes)")
}
